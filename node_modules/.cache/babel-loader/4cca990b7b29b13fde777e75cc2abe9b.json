{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Op = Object.prototype;\nvar objToStr = Op.toString;\nvar hasOwn = Op.hasOwnProperty;\n\nvar BaseType =\n/** @class */\nfunction () {\n  function BaseType() {}\n\n  BaseType.prototype.assert = function (value, deep) {\n    if (!this.check(value, deep)) {\n      var str = shallowStringify(value);\n      throw new Error(str + \" does not match type \" + this);\n    }\n\n    return true;\n  };\n\n  BaseType.prototype.arrayOf = function () {\n    var elemType = this;\n    return new ArrayType(elemType);\n  };\n\n  return BaseType;\n}();\n\nvar ArrayType =\n/** @class */\nfunction (_super) {\n  __extends(ArrayType, _super);\n\n  function ArrayType(elemType) {\n    var _this = _super.call(this) || this;\n\n    _this.elemType = elemType;\n    _this.kind = \"ArrayType\";\n    return _this;\n  }\n\n  ArrayType.prototype.toString = function () {\n    return \"[\" + this.elemType + \"]\";\n  };\n\n  ArrayType.prototype.check = function (value, deep) {\n    var _this = this;\n\n    return Array.isArray(value) && value.every(function (elem) {\n      return _this.elemType.check(elem, deep);\n    });\n  };\n\n  return ArrayType;\n}(BaseType);\n\nvar IdentityType =\n/** @class */\nfunction (_super) {\n  __extends(IdentityType, _super);\n\n  function IdentityType(value) {\n    var _this = _super.call(this) || this;\n\n    _this.value = value;\n    _this.kind = \"IdentityType\";\n    return _this;\n  }\n\n  IdentityType.prototype.toString = function () {\n    return String(this.value);\n  };\n\n  IdentityType.prototype.check = function (value, deep) {\n    var result = value === this.value;\n\n    if (!result && typeof deep === \"function\") {\n      deep(this, value);\n    }\n\n    return result;\n  };\n\n  return IdentityType;\n}(BaseType);\n\nvar ObjectType =\n/** @class */\nfunction (_super) {\n  __extends(ObjectType, _super);\n\n  function ObjectType(fields) {\n    var _this = _super.call(this) || this;\n\n    _this.fields = fields;\n    _this.kind = \"ObjectType\";\n    return _this;\n  }\n\n  ObjectType.prototype.toString = function () {\n    return \"{ \" + this.fields.join(\", \") + \" }\";\n  };\n\n  ObjectType.prototype.check = function (value, deep) {\n    return objToStr.call(value) === objToStr.call({}) && this.fields.every(function (field) {\n      return field.type.check(value[field.name], deep);\n    });\n  };\n\n  return ObjectType;\n}(BaseType);\n\nvar OrType =\n/** @class */\nfunction (_super) {\n  __extends(OrType, _super);\n\n  function OrType(types) {\n    var _this = _super.call(this) || this;\n\n    _this.types = types;\n    _this.kind = \"OrType\";\n    return _this;\n  }\n\n  OrType.prototype.toString = function () {\n    return this.types.join(\" | \");\n  };\n\n  OrType.prototype.check = function (value, deep) {\n    return this.types.some(function (type) {\n      return type.check(value, deep);\n    });\n  };\n\n  return OrType;\n}(BaseType);\n\nvar PredicateType =\n/** @class */\nfunction (_super) {\n  __extends(PredicateType, _super);\n\n  function PredicateType(name, predicate) {\n    var _this = _super.call(this) || this;\n\n    _this.name = name;\n    _this.predicate = predicate;\n    _this.kind = \"PredicateType\";\n    return _this;\n  }\n\n  PredicateType.prototype.toString = function () {\n    return this.name;\n  };\n\n  PredicateType.prototype.check = function (value, deep) {\n    var result = this.predicate(value, deep);\n\n    if (!result && typeof deep === \"function\") {\n      deep(this, value);\n    }\n\n    return result;\n  };\n\n  return PredicateType;\n}(BaseType);\n\nvar Def =\n/** @class */\nfunction () {\n  function Def(type, typeName) {\n    this.type = type;\n    this.typeName = typeName;\n    this.baseNames = [];\n    this.ownFields = Object.create(null); // Includes own typeName. Populated during finalization.\n\n    this.allSupertypes = Object.create(null); // Linear inheritance hierarchy. Populated during finalization.\n\n    this.supertypeList = []; // Includes inherited fields.\n\n    this.allFields = Object.create(null); // Non-hidden keys of allFields.\n\n    this.fieldNames = []; // This property will be overridden as true by individual Def instances\n    // when they are finalized.\n\n    this.finalized = false; // False by default until .build(...) is called on an instance.\n\n    this.buildable = false;\n    this.buildParams = [];\n  }\n\n  Def.prototype.isSupertypeOf = function (that) {\n    if (that instanceof Def) {\n      if (this.finalized !== true || that.finalized !== true) {\n        throw new Error(\"\");\n      }\n\n      return hasOwn.call(that.allSupertypes, this.typeName);\n    } else {\n      throw new Error(that + \" is not a Def\");\n    }\n  };\n\n  Def.prototype.checkAllFields = function (value, deep) {\n    var allFields = this.allFields;\n\n    if (this.finalized !== true) {\n      throw new Error(\"\" + this.typeName);\n    }\n\n    function checkFieldByName(name) {\n      var field = allFields[name];\n      var type = field.type;\n      var child = field.getValue(value);\n      return type.check(child, deep);\n    }\n\n    return value !== null && typeof value === \"object\" && Object.keys(allFields).every(checkFieldByName);\n  };\n\n  Def.prototype.bases = function () {\n    var supertypeNames = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      supertypeNames[_i] = arguments[_i];\n    }\n\n    var bases = this.baseNames;\n\n    if (this.finalized) {\n      if (supertypeNames.length !== bases.length) {\n        throw new Error(\"\");\n      }\n\n      for (var i = 0; i < supertypeNames.length; i++) {\n        if (supertypeNames[i] !== bases[i]) {\n          throw new Error(\"\");\n        }\n      }\n\n      return this;\n    }\n\n    supertypeNames.forEach(function (baseName) {\n      // This indexOf lookup may be O(n), but the typical number of base\n      // names is very small, and indexOf is a native Array method.\n      if (bases.indexOf(baseName) < 0) {\n        bases.push(baseName);\n      }\n    });\n    return this; // For chaining.\n  };\n\n  return Def;\n}();\n\nexports.Def = Def;\n\nvar Field =\n/** @class */\nfunction () {\n  function Field(name, type, defaultFn, hidden) {\n    this.name = name;\n    this.type = type;\n    this.defaultFn = defaultFn;\n    this.hidden = !!hidden;\n  }\n\n  Field.prototype.toString = function () {\n    return JSON.stringify(this.name) + \": \" + this.type;\n  };\n\n  Field.prototype.getValue = function (obj) {\n    var value = obj[this.name];\n\n    if (typeof value !== \"undefined\") {\n      return value;\n    }\n\n    if (typeof this.defaultFn === \"function\") {\n      value = this.defaultFn.call(obj);\n    }\n\n    return value;\n  };\n\n  return Field;\n}();\n\nfunction shallowStringify(value) {\n  if (Array.isArray(value)) {\n    return \"[\" + value.map(shallowStringify).join(\", \") + \"]\";\n  }\n\n  if (value && typeof value === \"object\") {\n    return \"{ \" + Object.keys(value).map(function (key) {\n      return key + \": \" + value[key];\n    }).join(\", \") + \" }\";\n  }\n\n  return JSON.stringify(value);\n}\n\nfunction typesPlugin(_fork) {\n  var Type = {\n    or: function () {\n      var types = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        types[_i] = arguments[_i];\n      }\n\n      return new OrType(types.map(function (type) {\n        return Type.from(type);\n      }));\n    },\n    from: function (value, name) {\n      if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType) {\n        return value;\n      } // The Def type is used as a helper for constructing compound\n      // interface types for AST nodes.\n\n\n      if (value instanceof Def) {\n        return value.type;\n      } // Support [ElemType] syntax.\n\n\n      if (isArray.check(value)) {\n        if (value.length !== 1) {\n          throw new Error(\"only one element type is permitted for typed arrays\");\n        }\n\n        return new ArrayType(Type.from(value[0]));\n      } // Support { someField: FieldType, ... } syntax.\n\n\n      if (isObject.check(value)) {\n        return new ObjectType(Object.keys(value).map(function (name) {\n          return new Field(name, Type.from(value[name], name));\n        }));\n      }\n\n      if (typeof value === \"function\") {\n        var bicfIndex = builtInCtorFns.indexOf(value);\n\n        if (bicfIndex >= 0) {\n          return builtInCtorTypes[bicfIndex];\n        }\n\n        if (typeof name !== \"string\") {\n          throw new Error(\"missing name\");\n        }\n\n        return new PredicateType(name, value);\n      } // As a last resort, toType returns a type that matches any value that\n      // is === from. This is primarily useful for literal values like\n      // toType(null), but it has the additional advantage of allowing\n      // toType to be a total function.\n\n\n      return new IdentityType(value);\n    },\n    // Define a type whose name is registered in a namespace (the defCache) so\n    // that future definitions will return the same type given the same name.\n    // In particular, this system allows for circular and forward definitions.\n    // The Def object d returned from Type.def may be used to configure the\n    // type d.type by calling methods such as d.bases, d.build, and d.field.\n    def: function (typeName) {\n      return hasOwn.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);\n    },\n    hasDef: function (typeName) {\n      return hasOwn.call(defCache, typeName);\n    }\n  };\n  var builtInCtorFns = [];\n  var builtInCtorTypes = [];\n  var builtInTypes = {};\n\n  function defBuiltInType(example, name) {\n    var objStr = objToStr.call(example);\n    var type = new PredicateType(name, function (value) {\n      return objToStr.call(value) === objStr;\n    });\n    builtInTypes[name] = type;\n\n    if (example && typeof example.constructor === \"function\") {\n      builtInCtorFns.push(example.constructor);\n      builtInCtorTypes.push(type);\n    }\n\n    return type;\n  } // These types check the underlying [[Class]] attribute of the given\n  // value, rather than using the problematic typeof operator. Note however\n  // that no subtyping is considered; so, for instance, isObject.check\n  // returns false for [], /./, new Date, and null.\n\n\n  var isString = defBuiltInType(\"truthy\", \"string\");\n  var isFunction = defBuiltInType(function () {}, \"function\");\n  var isArray = defBuiltInType([], \"array\");\n  var isObject = defBuiltInType({}, \"object\");\n  var isRegExp = defBuiltInType(/./, \"RegExp\");\n  var isDate = defBuiltInType(new Date(), \"Date\");\n  var isNumber = defBuiltInType(3, \"number\");\n  var isBoolean = defBuiltInType(true, \"boolean\");\n  var isNull = defBuiltInType(null, \"null\");\n  var isUndefined = defBuiltInType(void 0, \"undefined\"); // In order to return the same Def instance every time Type.def is called\n  // with a particular name, those instances need to be stored in a cache.\n\n  var defCache = Object.create(null);\n\n  function defFromValue(value) {\n    if (value && typeof value === \"object\") {\n      var type = value.type;\n\n      if (typeof type === \"string\" && hasOwn.call(defCache, type)) {\n        var d = defCache[type];\n\n        if (d.finalized) {\n          return d;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  var DefImpl =\n  /** @class */\n  function (_super) {\n    __extends(DefImpl, _super);\n\n    function DefImpl(typeName) {\n      var _this = _super.call(this, new PredicateType(typeName, function (value, deep) {\n        return _this.check(value, deep);\n      }), typeName) || this;\n\n      return _this;\n    }\n\n    DefImpl.prototype.check = function (value, deep) {\n      if (this.finalized !== true) {\n        throw new Error(\"prematurely checking unfinalized type \" + this.typeName);\n      } // A Def type can only match an object value.\n\n\n      if (value === null || typeof value !== \"object\") {\n        return false;\n      }\n\n      var vDef = defFromValue(value);\n\n      if (!vDef) {\n        // If we couldn't infer the Def associated with the given value,\n        // and we expected it to be a SourceLocation or a Position, it was\n        // probably just missing a \"type\" field (because Esprima does not\n        // assign a type property to such nodes). Be optimistic and let\n        // this.checkAllFields make the final decision.\n        if (this.typeName === \"SourceLocation\" || this.typeName === \"Position\") {\n          return this.checkAllFields(value, deep);\n        } // Calling this.checkAllFields for any other type of node is both\n        // bad for performance and way too forgiving.\n\n\n        return false;\n      } // If checking deeply and vDef === this, then we only need to call\n      // checkAllFields once. Calling checkAllFields is too strict when deep\n      // is false, because then we only care about this.isSupertypeOf(vDef).\n\n\n      if (deep && vDef === this) {\n        return this.checkAllFields(value, deep);\n      } // In most cases we rely exclusively on isSupertypeOf to make O(1)\n      // subtyping determinations. This suffices in most situations outside\n      // of unit tests, since interface conformance is checked whenever new\n      // instances are created using builder functions.\n\n\n      if (!this.isSupertypeOf(vDef)) {\n        return false;\n      } // The exception is when deep is true; then, we recursively check all\n      // fields.\n\n\n      if (!deep) {\n        return true;\n      } // Use the more specific Def (vDef) to perform the deep check, but\n      // shallow-check fields defined by the less specific Def (this).\n\n\n      return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);\n    };\n\n    DefImpl.prototype.build = function () {\n      var _this = this;\n\n      var buildParams = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        buildParams[_i] = arguments[_i];\n      } // Calling Def.prototype.build multiple times has the effect of merely\n      // redefining this property.\n\n\n      this.buildParams = buildParams;\n\n      if (this.buildable) {\n        // If this Def is already buildable, update self.buildParams and\n        // continue using the old builder function.\n        return this;\n      } // Every buildable type will have its \"type\" field filled in\n      // automatically. This includes types that are not subtypes of Node,\n      // like SourceLocation, but that seems harmless (TODO?).\n\n\n      this.field(\"type\", String, function () {\n        return _this.typeName;\n      }); // Override Dp.buildable for this Def instance.\n\n      this.buildable = true;\n\n      var addParam = function (built, param, arg, isArgAvailable) {\n        if (hasOwn.call(built, param)) return;\n        var all = _this.allFields;\n\n        if (!hasOwn.call(all, param)) {\n          throw new Error(\"\" + param);\n        }\n\n        var field = all[param];\n        var type = field.type;\n        var value;\n\n        if (isArgAvailable) {\n          value = arg;\n        } else if (field.defaultFn) {\n          // Expose the partially-built object to the default\n          // function as its `this` object.\n          value = field.defaultFn.call(built);\n        } else {\n          var message = \"no value or default function given for field \" + JSON.stringify(param) + \" of \" + _this.typeName + \"(\" + _this.buildParams.map(function (name) {\n            return all[name];\n          }).join(\", \") + \")\";\n          throw new Error(message);\n        }\n\n        if (!type.check(value)) {\n          throw new Error(shallowStringify(value) + \" does not match field \" + field + \" of type \" + _this.typeName);\n        }\n\n        built[param] = value;\n      }; // Calling the builder function will construct an instance of the Def,\n      // with positional arguments mapped to the fields original passed to .build.\n      // If not enough arguments are provided, the default value for the remaining fields\n      // will be used.\n\n\n      var builder = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var argc = args.length;\n\n        if (!_this.finalized) {\n          throw new Error(\"attempting to instantiate unfinalized type \" + _this.typeName);\n        }\n\n        var built = Object.create(nodePrototype);\n\n        _this.buildParams.forEach(function (param, i) {\n          if (i < argc) {\n            addParam(built, param, args[i], true);\n          } else {\n            addParam(built, param, null, false);\n          }\n        });\n\n        Object.keys(_this.allFields).forEach(function (param) {\n          // Use the default value.\n          addParam(built, param, null, false);\n        }); // Make sure that the \"type\" field was filled automatically.\n\n        if (built.type !== _this.typeName) {\n          throw new Error(\"\");\n        }\n\n        return built;\n      }; // Calling .from on the builder function will construct an instance of the Def,\n      // using field values from the passed object. For fields missing from the passed object,\n      // their default value will be used.\n\n\n      builder.from = function (obj) {\n        if (!_this.finalized) {\n          throw new Error(\"attempting to instantiate unfinalized type \" + _this.typeName);\n        }\n\n        var built = Object.create(nodePrototype);\n        Object.keys(_this.allFields).forEach(function (param) {\n          if (hasOwn.call(obj, param)) {\n            addParam(built, param, obj[param], true);\n          } else {\n            addParam(built, param, null, false);\n          }\n        }); // Make sure that the \"type\" field was filled automatically.\n\n        if (built.type !== _this.typeName) {\n          throw new Error(\"\");\n        }\n\n        return built;\n      };\n\n      Object.defineProperty(builders, getBuilderName(this.typeName), {\n        enumerable: true,\n        value: builder\n      });\n      return this;\n    }; // The reason fields are specified using .field(...) instead of an object\n    // literal syntax is somewhat subtle: the object literal syntax would\n    // support only one key and one value, but with .field(...) we can pass\n    // any number of arguments to specify the field.\n\n\n    DefImpl.prototype.field = function (name, type, defaultFn, hidden) {\n      if (this.finalized) {\n        console.error(\"Ignoring attempt to redefine field \" + JSON.stringify(name) + \" of finalized type \" + JSON.stringify(this.typeName));\n        return this;\n      }\n\n      this.ownFields[name] = new Field(name, Type.from(type), defaultFn, hidden);\n      return this; // For chaining.\n    };\n\n    DefImpl.prototype.finalize = function () {\n      var _this = this; // It's not an error to finalize a type more than once, but only the\n      // first call to .finalize does anything.\n\n\n      if (!this.finalized) {\n        var allFields = this.allFields;\n        var allSupertypes = this.allSupertypes;\n        this.baseNames.forEach(function (name) {\n          var def = defCache[name];\n\n          if (def instanceof Def) {\n            def.finalize();\n            extend(allFields, def.allFields);\n            extend(allSupertypes, def.allSupertypes);\n          } else {\n            var message = \"unknown supertype name \" + JSON.stringify(name) + \" for subtype \" + JSON.stringify(_this.typeName);\n            throw new Error(message);\n          }\n        }); // TODO Warn if fields are overridden with incompatible types.\n\n        extend(allFields, this.ownFields);\n        allSupertypes[this.typeName] = this;\n        this.fieldNames.length = 0;\n\n        for (var fieldName in allFields) {\n          if (hasOwn.call(allFields, fieldName) && !allFields[fieldName].hidden) {\n            this.fieldNames.push(fieldName);\n          }\n        } // Types are exported only once they have been finalized.\n\n\n        Object.defineProperty(namedTypes, this.typeName, {\n          enumerable: true,\n          value: this.type\n        });\n        this.finalized = true; // A linearization of the inheritance hierarchy.\n\n        populateSupertypeList(this.typeName, this.supertypeList);\n\n        if (this.buildable && this.supertypeList.lastIndexOf(\"Expression\") >= 0) {\n          wrapExpressionBuilderWithStatement(this.typeName);\n        }\n      }\n    };\n\n    return DefImpl;\n  }(Def); // Note that the list returned by this function is a copy of the internal\n  // supertypeList, *without* the typeName itself as the first element.\n\n\n  function getSupertypeNames(typeName) {\n    if (!hasOwn.call(defCache, typeName)) {\n      throw new Error(\"\");\n    }\n\n    var d = defCache[typeName];\n\n    if (d.finalized !== true) {\n      throw new Error(\"\");\n    }\n\n    return d.supertypeList.slice(1);\n  } // Returns an object mapping from every known type in the defCache to the\n  // most specific supertype whose name is an own property of the candidates\n  // object.\n\n\n  function computeSupertypeLookupTable(candidates) {\n    var table = {};\n    var typeNames = Object.keys(defCache);\n    var typeNameCount = typeNames.length;\n\n    for (var i = 0; i < typeNameCount; ++i) {\n      var typeName = typeNames[i];\n      var d = defCache[typeName];\n\n      if (d.finalized !== true) {\n        throw new Error(\"\" + typeName);\n      }\n\n      for (var j = 0; j < d.supertypeList.length; ++j) {\n        var superTypeName = d.supertypeList[j];\n\n        if (hasOwn.call(candidates, superTypeName)) {\n          table[typeName] = superTypeName;\n          break;\n        }\n      }\n    }\n\n    return table;\n  }\n\n  var builders = Object.create(null); // This object is used as prototype for any node created by a builder.\n\n  var nodePrototype = {}; // Call this function to define a new method to be shared by all AST\n  // nodes. The replaced method (if any) is returned for easy wrapping.\n\n  function defineMethod(name, func) {\n    var old = nodePrototype[name]; // Pass undefined as func to delete nodePrototype[name].\n\n    if (isUndefined.check(func)) {\n      delete nodePrototype[name];\n    } else {\n      isFunction.assert(func);\n      Object.defineProperty(nodePrototype, name, {\n        enumerable: true,\n        configurable: true,\n        value: func\n      });\n    }\n\n    return old;\n  }\n\n  function getBuilderName(typeName) {\n    return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {\n      var len = upperCasePrefix.length;\n\n      switch (len) {\n        case 0:\n          return \"\";\n        // If there's only one initial capital letter, just lower-case it.\n\n        case 1:\n          return upperCasePrefix.toLowerCase();\n\n        default:\n          // If there's more than one initial capital letter, lower-case\n          // all but the last one, so that XMLDefaultDeclaration (for\n          // example) becomes xmlDefaultDeclaration.\n          return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);\n      }\n    });\n  }\n\n  function getStatementBuilderName(typeName) {\n    typeName = getBuilderName(typeName);\n    return typeName.replace(/(Expression)?$/, \"Statement\");\n  }\n\n  var namedTypes = {}; // Like Object.keys, but aware of what fields each AST type should have.\n\n  function getFieldNames(object) {\n    var d = defFromValue(object);\n\n    if (d) {\n      return d.fieldNames.slice(0);\n    }\n\n    if (\"type\" in object) {\n      throw new Error(\"did not recognize object of type \" + JSON.stringify(object.type));\n    }\n\n    return Object.keys(object);\n  } // Get the value of an object property, taking object.type and default\n  // functions into account.\n\n\n  function getFieldValue(object, fieldName) {\n    var d = defFromValue(object);\n\n    if (d) {\n      var field = d.allFields[fieldName];\n\n      if (field) {\n        return field.getValue(object);\n      }\n    }\n\n    return object && object[fieldName];\n  } // Iterate over all defined fields of an object, including those missing\n  // or undefined, passing each field name and effective value (as returned\n  // by getFieldValue) to the callback. If the object has no corresponding\n  // Def, the callback will never be called.\n\n\n  function eachField(object, callback, context) {\n    getFieldNames(object).forEach(function (name) {\n      callback.call(this, name, getFieldValue(object, name));\n    }, context);\n  } // Similar to eachField, except that iteration stops as soon as the\n  // callback returns a truthy value. Like Array.prototype.some, the final\n  // result is either true or false to indicates whether the callback\n  // returned true for any element or not.\n\n\n  function someField(object, callback, context) {\n    return getFieldNames(object).some(function (name) {\n      return callback.call(this, name, getFieldValue(object, name));\n    }, context);\n  } // Adds an additional builder for Expression subtypes\n  // that wraps the built Expression in an ExpressionStatements.\n\n\n  function wrapExpressionBuilderWithStatement(typeName) {\n    var wrapperName = getStatementBuilderName(typeName); // skip if the builder already exists\n\n    if (builders[wrapperName]) return; // the builder function to wrap with builders.ExpressionStatement\n\n    var wrapped = builders[getBuilderName(typeName)]; // skip if there is nothing to wrap\n\n    if (!wrapped) return;\n\n    var builder = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return builders.expressionStatement(wrapped.apply(builders, args));\n    };\n\n    builder.from = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return builders.expressionStatement(wrapped.from.apply(builders, args));\n    };\n\n    builders[wrapperName] = builder;\n  }\n\n  function populateSupertypeList(typeName, list) {\n    list.length = 0;\n    list.push(typeName);\n    var lastSeen = Object.create(null);\n\n    for (var pos = 0; pos < list.length; ++pos) {\n      typeName = list[pos];\n      var d = defCache[typeName];\n\n      if (d.finalized !== true) {\n        throw new Error(\"\");\n      } // If we saw typeName earlier in the breadth-first traversal,\n      // delete the last-seen occurrence.\n\n\n      if (hasOwn.call(lastSeen, typeName)) {\n        delete list[lastSeen[typeName]];\n      } // Record the new index of the last-seen occurrence of typeName.\n\n\n      lastSeen[typeName] = pos; // Enqueue the base names of this type.\n\n      list.push.apply(list, d.baseNames);\n    } // Compaction loop to remove array holes.\n\n\n    for (var to = 0, from = to, len = list.length; from < len; ++from) {\n      if (hasOwn.call(list, from)) {\n        list[to++] = list[from];\n      }\n    }\n\n    list.length = to;\n  }\n\n  function extend(into, from) {\n    Object.keys(from).forEach(function (name) {\n      into[name] = from[name];\n    });\n    return into;\n  }\n\n  function finalize() {\n    Object.keys(defCache).forEach(function (name) {\n      defCache[name].finalize();\n    });\n  }\n\n  return {\n    Type: Type,\n    builtInTypes: builtInTypes,\n    getSupertypeNames: getSupertypeNames,\n    computeSupertypeLookupTable: computeSupertypeLookupTable,\n    builders: builders,\n    defineMethod: defineMethod,\n    getBuilderName: getBuilderName,\n    getStatementBuilderName: getStatementBuilderName,\n    namedTypes: namedTypes,\n    getFieldNames: getFieldNames,\n    getFieldValue: getFieldValue,\n    eachField: eachField,\n    someField: someField,\n    finalize: finalize\n  };\n}\n\nexports.default = typesPlugin;\n;","map":{"version":3,"sources":["/Users/owner/Desktop/Naples/ReactJS/Rancell-Portfolio/node_modules/ast-types/lib/types.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","exports","value","Op","objToStr","toString","hasOwn","BaseType","assert","deep","check","str","shallowStringify","Error","arrayOf","elemType","ArrayType","_super","_this","call","kind","isArray","every","elem","IdentityType","String","result","ObjectType","fields","join","field","type","name","OrType","types","some","PredicateType","predicate","Def","typeName","baseNames","ownFields","allSupertypes","supertypeList","allFields","fieldNames","finalized","buildable","buildParams","isSupertypeOf","that","checkAllFields","checkFieldByName","child","getValue","keys","bases","supertypeNames","_i","arguments","length","i","forEach","baseName","indexOf","push","Field","defaultFn","hidden","JSON","stringify","obj","map","key","typesPlugin","_fork","Type","or","from","isObject","bicfIndex","builtInCtorFns","builtInCtorTypes","def","defCache","DefImpl","hasDef","builtInTypes","defBuiltInType","example","objStr","isString","isFunction","isRegExp","isDate","Date","isNumber","isBoolean","isNull","isUndefined","defFromValue","vDef","build","addParam","built","param","arg","isArgAvailable","all","message","builder","args","argc","nodePrototype","builders","getBuilderName","enumerable","console","error","finalize","extend","fieldName","namedTypes","populateSupertypeList","lastIndexOf","wrapExpressionBuilderWithStatement","getSupertypeNames","slice","computeSupertypeLookupTable","candidates","table","typeNames","typeNameCount","j","superTypeName","defineMethod","func","old","configurable","replace","upperCasePrefix","len","toLowerCase","charAt","getStatementBuilderName","getFieldNames","object","getFieldValue","eachField","callback","context","someField","wrapperName","wrapped","expressionStatement","apply","list","lastSeen","pos","to","into","default"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Op = Object.prototype;\nvar objToStr = Op.toString;\nvar hasOwn = Op.hasOwnProperty;\nvar BaseType = /** @class */ (function () {\n    function BaseType() {\n    }\n    BaseType.prototype.assert = function (value, deep) {\n        if (!this.check(value, deep)) {\n            var str = shallowStringify(value);\n            throw new Error(str + \" does not match type \" + this);\n        }\n        return true;\n    };\n    BaseType.prototype.arrayOf = function () {\n        var elemType = this;\n        return new ArrayType(elemType);\n    };\n    return BaseType;\n}());\nvar ArrayType = /** @class */ (function (_super) {\n    __extends(ArrayType, _super);\n    function ArrayType(elemType) {\n        var _this = _super.call(this) || this;\n        _this.elemType = elemType;\n        _this.kind = \"ArrayType\";\n        return _this;\n    }\n    ArrayType.prototype.toString = function () {\n        return \"[\" + this.elemType + \"]\";\n    };\n    ArrayType.prototype.check = function (value, deep) {\n        var _this = this;\n        return Array.isArray(value) && value.every(function (elem) { return _this.elemType.check(elem, deep); });\n    };\n    return ArrayType;\n}(BaseType));\nvar IdentityType = /** @class */ (function (_super) {\n    __extends(IdentityType, _super);\n    function IdentityType(value) {\n        var _this = _super.call(this) || this;\n        _this.value = value;\n        _this.kind = \"IdentityType\";\n        return _this;\n    }\n    IdentityType.prototype.toString = function () {\n        return String(this.value);\n    };\n    IdentityType.prototype.check = function (value, deep) {\n        var result = value === this.value;\n        if (!result && typeof deep === \"function\") {\n            deep(this, value);\n        }\n        return result;\n    };\n    return IdentityType;\n}(BaseType));\nvar ObjectType = /** @class */ (function (_super) {\n    __extends(ObjectType, _super);\n    function ObjectType(fields) {\n        var _this = _super.call(this) || this;\n        _this.fields = fields;\n        _this.kind = \"ObjectType\";\n        return _this;\n    }\n    ObjectType.prototype.toString = function () {\n        return \"{ \" + this.fields.join(\", \") + \" }\";\n    };\n    ObjectType.prototype.check = function (value, deep) {\n        return (objToStr.call(value) === objToStr.call({}) &&\n            this.fields.every(function (field) {\n                return field.type.check(value[field.name], deep);\n            }));\n    };\n    return ObjectType;\n}(BaseType));\nvar OrType = /** @class */ (function (_super) {\n    __extends(OrType, _super);\n    function OrType(types) {\n        var _this = _super.call(this) || this;\n        _this.types = types;\n        _this.kind = \"OrType\";\n        return _this;\n    }\n    OrType.prototype.toString = function () {\n        return this.types.join(\" | \");\n    };\n    OrType.prototype.check = function (value, deep) {\n        return this.types.some(function (type) {\n            return type.check(value, deep);\n        });\n    };\n    return OrType;\n}(BaseType));\nvar PredicateType = /** @class */ (function (_super) {\n    __extends(PredicateType, _super);\n    function PredicateType(name, predicate) {\n        var _this = _super.call(this) || this;\n        _this.name = name;\n        _this.predicate = predicate;\n        _this.kind = \"PredicateType\";\n        return _this;\n    }\n    PredicateType.prototype.toString = function () {\n        return this.name;\n    };\n    PredicateType.prototype.check = function (value, deep) {\n        var result = this.predicate(value, deep);\n        if (!result && typeof deep === \"function\") {\n            deep(this, value);\n        }\n        return result;\n    };\n    return PredicateType;\n}(BaseType));\nvar Def = /** @class */ (function () {\n    function Def(type, typeName) {\n        this.type = type;\n        this.typeName = typeName;\n        this.baseNames = [];\n        this.ownFields = Object.create(null);\n        // Includes own typeName. Populated during finalization.\n        this.allSupertypes = Object.create(null);\n        // Linear inheritance hierarchy. Populated during finalization.\n        this.supertypeList = [];\n        // Includes inherited fields.\n        this.allFields = Object.create(null);\n        // Non-hidden keys of allFields.\n        this.fieldNames = [];\n        // This property will be overridden as true by individual Def instances\n        // when they are finalized.\n        this.finalized = false;\n        // False by default until .build(...) is called on an instance.\n        this.buildable = false;\n        this.buildParams = [];\n    }\n    Def.prototype.isSupertypeOf = function (that) {\n        if (that instanceof Def) {\n            if (this.finalized !== true ||\n                that.finalized !== true) {\n                throw new Error(\"\");\n            }\n            return hasOwn.call(that.allSupertypes, this.typeName);\n        }\n        else {\n            throw new Error(that + \" is not a Def\");\n        }\n    };\n    Def.prototype.checkAllFields = function (value, deep) {\n        var allFields = this.allFields;\n        if (this.finalized !== true) {\n            throw new Error(\"\" + this.typeName);\n        }\n        function checkFieldByName(name) {\n            var field = allFields[name];\n            var type = field.type;\n            var child = field.getValue(value);\n            return type.check(child, deep);\n        }\n        return value !== null &&\n            typeof value === \"object\" &&\n            Object.keys(allFields).every(checkFieldByName);\n    };\n    Def.prototype.bases = function () {\n        var supertypeNames = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            supertypeNames[_i] = arguments[_i];\n        }\n        var bases = this.baseNames;\n        if (this.finalized) {\n            if (supertypeNames.length !== bases.length) {\n                throw new Error(\"\");\n            }\n            for (var i = 0; i < supertypeNames.length; i++) {\n                if (supertypeNames[i] !== bases[i]) {\n                    throw new Error(\"\");\n                }\n            }\n            return this;\n        }\n        supertypeNames.forEach(function (baseName) {\n            // This indexOf lookup may be O(n), but the typical number of base\n            // names is very small, and indexOf is a native Array method.\n            if (bases.indexOf(baseName) < 0) {\n                bases.push(baseName);\n            }\n        });\n        return this; // For chaining.\n    };\n    return Def;\n}());\nexports.Def = Def;\nvar Field = /** @class */ (function () {\n    function Field(name, type, defaultFn, hidden) {\n        this.name = name;\n        this.type = type;\n        this.defaultFn = defaultFn;\n        this.hidden = !!hidden;\n    }\n    Field.prototype.toString = function () {\n        return JSON.stringify(this.name) + \": \" + this.type;\n    };\n    Field.prototype.getValue = function (obj) {\n        var value = obj[this.name];\n        if (typeof value !== \"undefined\") {\n            return value;\n        }\n        if (typeof this.defaultFn === \"function\") {\n            value = this.defaultFn.call(obj);\n        }\n        return value;\n    };\n    return Field;\n}());\nfunction shallowStringify(value) {\n    if (Array.isArray(value)) {\n        return \"[\" + value.map(shallowStringify).join(\", \") + \"]\";\n    }\n    if (value && typeof value === \"object\") {\n        return \"{ \" + Object.keys(value).map(function (key) {\n            return key + \": \" + value[key];\n        }).join(\", \") + \" }\";\n    }\n    return JSON.stringify(value);\n}\nfunction typesPlugin(_fork) {\n    var Type = {\n        or: function () {\n            var types = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                types[_i] = arguments[_i];\n            }\n            return new OrType(types.map(function (type) { return Type.from(type); }));\n        },\n        from: function (value, name) {\n            if (value instanceof ArrayType ||\n                value instanceof IdentityType ||\n                value instanceof ObjectType ||\n                value instanceof OrType ||\n                value instanceof PredicateType) {\n                return value;\n            }\n            // The Def type is used as a helper for constructing compound\n            // interface types for AST nodes.\n            if (value instanceof Def) {\n                return value.type;\n            }\n            // Support [ElemType] syntax.\n            if (isArray.check(value)) {\n                if (value.length !== 1) {\n                    throw new Error(\"only one element type is permitted for typed arrays\");\n                }\n                return new ArrayType(Type.from(value[0]));\n            }\n            // Support { someField: FieldType, ... } syntax.\n            if (isObject.check(value)) {\n                return new ObjectType(Object.keys(value).map(function (name) {\n                    return new Field(name, Type.from(value[name], name));\n                }));\n            }\n            if (typeof value === \"function\") {\n                var bicfIndex = builtInCtorFns.indexOf(value);\n                if (bicfIndex >= 0) {\n                    return builtInCtorTypes[bicfIndex];\n                }\n                if (typeof name !== \"string\") {\n                    throw new Error(\"missing name\");\n                }\n                return new PredicateType(name, value);\n            }\n            // As a last resort, toType returns a type that matches any value that\n            // is === from. This is primarily useful for literal values like\n            // toType(null), but it has the additional advantage of allowing\n            // toType to be a total function.\n            return new IdentityType(value);\n        },\n        // Define a type whose name is registered in a namespace (the defCache) so\n        // that future definitions will return the same type given the same name.\n        // In particular, this system allows for circular and forward definitions.\n        // The Def object d returned from Type.def may be used to configure the\n        // type d.type by calling methods such as d.bases, d.build, and d.field.\n        def: function (typeName) {\n            return hasOwn.call(defCache, typeName)\n                ? defCache[typeName]\n                : defCache[typeName] = new DefImpl(typeName);\n        },\n        hasDef: function (typeName) {\n            return hasOwn.call(defCache, typeName);\n        }\n    };\n    var builtInCtorFns = [];\n    var builtInCtorTypes = [];\n    var builtInTypes = {};\n    function defBuiltInType(example, name) {\n        var objStr = objToStr.call(example);\n        var type = new PredicateType(name, function (value) { return objToStr.call(value) === objStr; });\n        builtInTypes[name] = type;\n        if (example && typeof example.constructor === \"function\") {\n            builtInCtorFns.push(example.constructor);\n            builtInCtorTypes.push(type);\n        }\n        return type;\n    }\n    // These types check the underlying [[Class]] attribute of the given\n    // value, rather than using the problematic typeof operator. Note however\n    // that no subtyping is considered; so, for instance, isObject.check\n    // returns false for [], /./, new Date, and null.\n    var isString = defBuiltInType(\"truthy\", \"string\");\n    var isFunction = defBuiltInType(function () { }, \"function\");\n    var isArray = defBuiltInType([], \"array\");\n    var isObject = defBuiltInType({}, \"object\");\n    var isRegExp = defBuiltInType(/./, \"RegExp\");\n    var isDate = defBuiltInType(new Date, \"Date\");\n    var isNumber = defBuiltInType(3, \"number\");\n    var isBoolean = defBuiltInType(true, \"boolean\");\n    var isNull = defBuiltInType(null, \"null\");\n    var isUndefined = defBuiltInType(void 0, \"undefined\");\n    // In order to return the same Def instance every time Type.def is called\n    // with a particular name, those instances need to be stored in a cache.\n    var defCache = Object.create(null);\n    function defFromValue(value) {\n        if (value && typeof value === \"object\") {\n            var type = value.type;\n            if (typeof type === \"string\" &&\n                hasOwn.call(defCache, type)) {\n                var d = defCache[type];\n                if (d.finalized) {\n                    return d;\n                }\n            }\n        }\n        return null;\n    }\n    var DefImpl = /** @class */ (function (_super) {\n        __extends(DefImpl, _super);\n        function DefImpl(typeName) {\n            var _this = _super.call(this, new PredicateType(typeName, function (value, deep) { return _this.check(value, deep); }), typeName) || this;\n            return _this;\n        }\n        DefImpl.prototype.check = function (value, deep) {\n            if (this.finalized !== true) {\n                throw new Error(\"prematurely checking unfinalized type \" + this.typeName);\n            }\n            // A Def type can only match an object value.\n            if (value === null || typeof value !== \"object\") {\n                return false;\n            }\n            var vDef = defFromValue(value);\n            if (!vDef) {\n                // If we couldn't infer the Def associated with the given value,\n                // and we expected it to be a SourceLocation or a Position, it was\n                // probably just missing a \"type\" field (because Esprima does not\n                // assign a type property to such nodes). Be optimistic and let\n                // this.checkAllFields make the final decision.\n                if (this.typeName === \"SourceLocation\" ||\n                    this.typeName === \"Position\") {\n                    return this.checkAllFields(value, deep);\n                }\n                // Calling this.checkAllFields for any other type of node is both\n                // bad for performance and way too forgiving.\n                return false;\n            }\n            // If checking deeply and vDef === this, then we only need to call\n            // checkAllFields once. Calling checkAllFields is too strict when deep\n            // is false, because then we only care about this.isSupertypeOf(vDef).\n            if (deep && vDef === this) {\n                return this.checkAllFields(value, deep);\n            }\n            // In most cases we rely exclusively on isSupertypeOf to make O(1)\n            // subtyping determinations. This suffices in most situations outside\n            // of unit tests, since interface conformance is checked whenever new\n            // instances are created using builder functions.\n            if (!this.isSupertypeOf(vDef)) {\n                return false;\n            }\n            // The exception is when deep is true; then, we recursively check all\n            // fields.\n            if (!deep) {\n                return true;\n            }\n            // Use the more specific Def (vDef) to perform the deep check, but\n            // shallow-check fields defined by the less specific Def (this).\n            return vDef.checkAllFields(value, deep)\n                && this.checkAllFields(value, false);\n        };\n        DefImpl.prototype.build = function () {\n            var _this = this;\n            var buildParams = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                buildParams[_i] = arguments[_i];\n            }\n            // Calling Def.prototype.build multiple times has the effect of merely\n            // redefining this property.\n            this.buildParams = buildParams;\n            if (this.buildable) {\n                // If this Def is already buildable, update self.buildParams and\n                // continue using the old builder function.\n                return this;\n            }\n            // Every buildable type will have its \"type\" field filled in\n            // automatically. This includes types that are not subtypes of Node,\n            // like SourceLocation, but that seems harmless (TODO?).\n            this.field(\"type\", String, function () { return _this.typeName; });\n            // Override Dp.buildable for this Def instance.\n            this.buildable = true;\n            var addParam = function (built, param, arg, isArgAvailable) {\n                if (hasOwn.call(built, param))\n                    return;\n                var all = _this.allFields;\n                if (!hasOwn.call(all, param)) {\n                    throw new Error(\"\" + param);\n                }\n                var field = all[param];\n                var type = field.type;\n                var value;\n                if (isArgAvailable) {\n                    value = arg;\n                }\n                else if (field.defaultFn) {\n                    // Expose the partially-built object to the default\n                    // function as its `this` object.\n                    value = field.defaultFn.call(built);\n                }\n                else {\n                    var message = \"no value or default function given for field \" +\n                        JSON.stringify(param) + \" of \" + _this.typeName + \"(\" +\n                        _this.buildParams.map(function (name) {\n                            return all[name];\n                        }).join(\", \") + \")\";\n                    throw new Error(message);\n                }\n                if (!type.check(value)) {\n                    throw new Error(shallowStringify(value) +\n                        \" does not match field \" + field +\n                        \" of type \" + _this.typeName);\n                }\n                built[param] = value;\n            };\n            // Calling the builder function will construct an instance of the Def,\n            // with positional arguments mapped to the fields original passed to .build.\n            // If not enough arguments are provided, the default value for the remaining fields\n            // will be used.\n            var builder = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var argc = args.length;\n                if (!_this.finalized) {\n                    throw new Error(\"attempting to instantiate unfinalized type \" +\n                        _this.typeName);\n                }\n                var built = Object.create(nodePrototype);\n                _this.buildParams.forEach(function (param, i) {\n                    if (i < argc) {\n                        addParam(built, param, args[i], true);\n                    }\n                    else {\n                        addParam(built, param, null, false);\n                    }\n                });\n                Object.keys(_this.allFields).forEach(function (param) {\n                    // Use the default value.\n                    addParam(built, param, null, false);\n                });\n                // Make sure that the \"type\" field was filled automatically.\n                if (built.type !== _this.typeName) {\n                    throw new Error(\"\");\n                }\n                return built;\n            };\n            // Calling .from on the builder function will construct an instance of the Def,\n            // using field values from the passed object. For fields missing from the passed object,\n            // their default value will be used.\n            builder.from = function (obj) {\n                if (!_this.finalized) {\n                    throw new Error(\"attempting to instantiate unfinalized type \" +\n                        _this.typeName);\n                }\n                var built = Object.create(nodePrototype);\n                Object.keys(_this.allFields).forEach(function (param) {\n                    if (hasOwn.call(obj, param)) {\n                        addParam(built, param, obj[param], true);\n                    }\n                    else {\n                        addParam(built, param, null, false);\n                    }\n                });\n                // Make sure that the \"type\" field was filled automatically.\n                if (built.type !== _this.typeName) {\n                    throw new Error(\"\");\n                }\n                return built;\n            };\n            Object.defineProperty(builders, getBuilderName(this.typeName), {\n                enumerable: true,\n                value: builder\n            });\n            return this;\n        };\n        // The reason fields are specified using .field(...) instead of an object\n        // literal syntax is somewhat subtle: the object literal syntax would\n        // support only one key and one value, but with .field(...) we can pass\n        // any number of arguments to specify the field.\n        DefImpl.prototype.field = function (name, type, defaultFn, hidden) {\n            if (this.finalized) {\n                console.error(\"Ignoring attempt to redefine field \" +\n                    JSON.stringify(name) + \" of finalized type \" +\n                    JSON.stringify(this.typeName));\n                return this;\n            }\n            this.ownFields[name] = new Field(name, Type.from(type), defaultFn, hidden);\n            return this; // For chaining.\n        };\n        DefImpl.prototype.finalize = function () {\n            var _this = this;\n            // It's not an error to finalize a type more than once, but only the\n            // first call to .finalize does anything.\n            if (!this.finalized) {\n                var allFields = this.allFields;\n                var allSupertypes = this.allSupertypes;\n                this.baseNames.forEach(function (name) {\n                    var def = defCache[name];\n                    if (def instanceof Def) {\n                        def.finalize();\n                        extend(allFields, def.allFields);\n                        extend(allSupertypes, def.allSupertypes);\n                    }\n                    else {\n                        var message = \"unknown supertype name \" +\n                            JSON.stringify(name) +\n                            \" for subtype \" +\n                            JSON.stringify(_this.typeName);\n                        throw new Error(message);\n                    }\n                });\n                // TODO Warn if fields are overridden with incompatible types.\n                extend(allFields, this.ownFields);\n                allSupertypes[this.typeName] = this;\n                this.fieldNames.length = 0;\n                for (var fieldName in allFields) {\n                    if (hasOwn.call(allFields, fieldName) &&\n                        !allFields[fieldName].hidden) {\n                        this.fieldNames.push(fieldName);\n                    }\n                }\n                // Types are exported only once they have been finalized.\n                Object.defineProperty(namedTypes, this.typeName, {\n                    enumerable: true,\n                    value: this.type\n                });\n                this.finalized = true;\n                // A linearization of the inheritance hierarchy.\n                populateSupertypeList(this.typeName, this.supertypeList);\n                if (this.buildable &&\n                    this.supertypeList.lastIndexOf(\"Expression\") >= 0) {\n                    wrapExpressionBuilderWithStatement(this.typeName);\n                }\n            }\n        };\n        return DefImpl;\n    }(Def));\n    // Note that the list returned by this function is a copy of the internal\n    // supertypeList, *without* the typeName itself as the first element.\n    function getSupertypeNames(typeName) {\n        if (!hasOwn.call(defCache, typeName)) {\n            throw new Error(\"\");\n        }\n        var d = defCache[typeName];\n        if (d.finalized !== true) {\n            throw new Error(\"\");\n        }\n        return d.supertypeList.slice(1);\n    }\n    // Returns an object mapping from every known type in the defCache to the\n    // most specific supertype whose name is an own property of the candidates\n    // object.\n    function computeSupertypeLookupTable(candidates) {\n        var table = {};\n        var typeNames = Object.keys(defCache);\n        var typeNameCount = typeNames.length;\n        for (var i = 0; i < typeNameCount; ++i) {\n            var typeName = typeNames[i];\n            var d = defCache[typeName];\n            if (d.finalized !== true) {\n                throw new Error(\"\" + typeName);\n            }\n            for (var j = 0; j < d.supertypeList.length; ++j) {\n                var superTypeName = d.supertypeList[j];\n                if (hasOwn.call(candidates, superTypeName)) {\n                    table[typeName] = superTypeName;\n                    break;\n                }\n            }\n        }\n        return table;\n    }\n    var builders = Object.create(null);\n    // This object is used as prototype for any node created by a builder.\n    var nodePrototype = {};\n    // Call this function to define a new method to be shared by all AST\n    // nodes. The replaced method (if any) is returned for easy wrapping.\n    function defineMethod(name, func) {\n        var old = nodePrototype[name];\n        // Pass undefined as func to delete nodePrototype[name].\n        if (isUndefined.check(func)) {\n            delete nodePrototype[name];\n        }\n        else {\n            isFunction.assert(func);\n            Object.defineProperty(nodePrototype, name, {\n                enumerable: true,\n                configurable: true,\n                value: func\n            });\n        }\n        return old;\n    }\n    function getBuilderName(typeName) {\n        return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {\n            var len = upperCasePrefix.length;\n            switch (len) {\n                case 0: return \"\";\n                // If there's only one initial capital letter, just lower-case it.\n                case 1: return upperCasePrefix.toLowerCase();\n                default:\n                    // If there's more than one initial capital letter, lower-case\n                    // all but the last one, so that XMLDefaultDeclaration (for\n                    // example) becomes xmlDefaultDeclaration.\n                    return upperCasePrefix.slice(0, len - 1).toLowerCase() +\n                        upperCasePrefix.charAt(len - 1);\n            }\n        });\n    }\n    function getStatementBuilderName(typeName) {\n        typeName = getBuilderName(typeName);\n        return typeName.replace(/(Expression)?$/, \"Statement\");\n    }\n    var namedTypes = {};\n    // Like Object.keys, but aware of what fields each AST type should have.\n    function getFieldNames(object) {\n        var d = defFromValue(object);\n        if (d) {\n            return d.fieldNames.slice(0);\n        }\n        if (\"type\" in object) {\n            throw new Error(\"did not recognize object of type \" +\n                JSON.stringify(object.type));\n        }\n        return Object.keys(object);\n    }\n    // Get the value of an object property, taking object.type and default\n    // functions into account.\n    function getFieldValue(object, fieldName) {\n        var d = defFromValue(object);\n        if (d) {\n            var field = d.allFields[fieldName];\n            if (field) {\n                return field.getValue(object);\n            }\n        }\n        return object && object[fieldName];\n    }\n    // Iterate over all defined fields of an object, including those missing\n    // or undefined, passing each field name and effective value (as returned\n    // by getFieldValue) to the callback. If the object has no corresponding\n    // Def, the callback will never be called.\n    function eachField(object, callback, context) {\n        getFieldNames(object).forEach(function (name) {\n            callback.call(this, name, getFieldValue(object, name));\n        }, context);\n    }\n    // Similar to eachField, except that iteration stops as soon as the\n    // callback returns a truthy value. Like Array.prototype.some, the final\n    // result is either true or false to indicates whether the callback\n    // returned true for any element or not.\n    function someField(object, callback, context) {\n        return getFieldNames(object).some(function (name) {\n            return callback.call(this, name, getFieldValue(object, name));\n        }, context);\n    }\n    // Adds an additional builder for Expression subtypes\n    // that wraps the built Expression in an ExpressionStatements.\n    function wrapExpressionBuilderWithStatement(typeName) {\n        var wrapperName = getStatementBuilderName(typeName);\n        // skip if the builder already exists\n        if (builders[wrapperName])\n            return;\n        // the builder function to wrap with builders.ExpressionStatement\n        var wrapped = builders[getBuilderName(typeName)];\n        // skip if there is nothing to wrap\n        if (!wrapped)\n            return;\n        var builder = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return builders.expressionStatement(wrapped.apply(builders, args));\n        };\n        builder.from = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return builders.expressionStatement(wrapped.from.apply(builders, args));\n        };\n        builders[wrapperName] = builder;\n    }\n    function populateSupertypeList(typeName, list) {\n        list.length = 0;\n        list.push(typeName);\n        var lastSeen = Object.create(null);\n        for (var pos = 0; pos < list.length; ++pos) {\n            typeName = list[pos];\n            var d = defCache[typeName];\n            if (d.finalized !== true) {\n                throw new Error(\"\");\n            }\n            // If we saw typeName earlier in the breadth-first traversal,\n            // delete the last-seen occurrence.\n            if (hasOwn.call(lastSeen, typeName)) {\n                delete list[lastSeen[typeName]];\n            }\n            // Record the new index of the last-seen occurrence of typeName.\n            lastSeen[typeName] = pos;\n            // Enqueue the base names of this type.\n            list.push.apply(list, d.baseNames);\n        }\n        // Compaction loop to remove array holes.\n        for (var to = 0, from = to, len = list.length; from < len; ++from) {\n            if (hasOwn.call(list, from)) {\n                list[to++] = list[from];\n            }\n        }\n        list.length = to;\n    }\n    function extend(into, from) {\n        Object.keys(from).forEach(function (name) {\n            into[name] = from[name];\n        });\n        return into;\n    }\n    function finalize() {\n        Object.keys(defCache).forEach(function (name) {\n            defCache[name].finalize();\n        });\n    }\n    return {\n        Type: Type,\n        builtInTypes: builtInTypes,\n        getSupertypeNames: getSupertypeNames,\n        computeSupertypeLookupTable: computeSupertypeLookupTable,\n        builders: builders,\n        defineMethod: defineMethod,\n        getBuilderName: getBuilderName,\n        getStatementBuilderName: getStatementBuilderName,\n        namedTypes: namedTypes,\n        getFieldNames: getFieldNames,\n        getFieldValue: getFieldValue,\n        eachField: eachField,\n        someField: someField,\n        finalize: finalize,\n    };\n}\nexports.default = typesPlugin;\n;\n"]},"metadata":{},"sourceType":"script"}