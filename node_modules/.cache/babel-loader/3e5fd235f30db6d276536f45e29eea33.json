{"ast":null,"code":"const https = require('https');\n\nconst http = require('http');\n\nconst ProxyAgent = require('proxy-agent');\n\nconst qs = require('querystring');\n\nconst fs = require('fs');\n\nconst Readable = require('stream').Readable;\n\nconst FormData = require('form-data');\n\nconst Attachment = require('./attachment');\n\nconst retry = require('async').retry;\n\nconst promisifyCall = require('promisify-call');\n\nconst debug = require('debug')('mailgun-js');\n\nfunction isOk(i) {\n  return typeof i !== 'undefined' && i !== null;\n}\n\nfunction getDataValue(key, input) {\n  if (isSpecialParam(key) && typeof input === 'object') {\n    return JSON.stringify(input);\n  } else if (typeof input === 'number' || typeof input === 'boolean') {\n    return input.toString();\n  }\n\n  return input;\n}\n\nfunction isSpecialParam(paramKey) {\n  const key = paramKey.toLowerCase();\n  return key === 'vars' || key === 'members' || key === 'recipient-variables' || key.indexOf('v:') === 0;\n}\n\nfunction isMultiUnsubsribe(path, data) {\n  return path.indexOf('/unsubscribes') && data && Array.isArray(data);\n}\n\nfunction prepareData(data) {\n  const params = {};\n\n  for (const key in data) {\n    if (key !== 'attachment' && key !== 'inline' && isOk(data[key])) {\n      const value = getDataValue(key, data[key]);\n\n      if (isOk(value)) {\n        params[key] = value;\n      }\n    } else {\n      params[key] = data[key];\n    }\n  }\n\n  return params;\n}\n\nclass Request {\n  constructor(options) {\n    this.host = options.host;\n    this.protocol = options.protocol;\n    this.port = options.port;\n    this.endpoint = options.endpoint;\n    this.auth = options.auth;\n    this.proxy = options.proxy;\n    this.timeout = options.timeout;\n    this.retry = options.retry || 1;\n    this.testMode = options.testMode;\n    this.testModeLogger = typeof options.testModeLogger === 'function' ? options.testModeLogger : this.defaultTestModeLogger;\n  }\n\n  _request(method, resource, data, fn) {\n    let path = ''.concat(this.endpoint, resource);\n    const params = prepareData(data);\n    this.payload = '';\n    const isMIME = path.indexOf('/messages.mime') >= 0;\n    this.headers = {};\n\n    if (method === 'GET' || method === 'DELETE') {\n      this.payload = qs.stringify(params);\n      if (this.payload) path = path.concat('?', this.payload);\n    } else {\n      if (isMIME) {\n        this.headers['Content-Type'] = 'multipart/form-data';\n      } else if (method === 'POST' && isMultiUnsubsribe(path, data)) {\n        this.headers['Content-Type'] = 'application/json';\n      } else {\n        this.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n      }\n\n      if (params && (params.attachment || params.inline || isMIME && params.message)) {\n        this.prepareFormData(params);\n      } else {\n        if (method === 'POST' && isMultiUnsubsribe(path, data)) {\n          this.payload = JSON.stringify(data);\n        } else {\n          this.payload = qs.stringify(params);\n        }\n\n        if (this.payload) {\n          this.headers['Content-Length'] = Buffer.byteLength(this.payload);\n        } else {\n          this.headers['Content-Length'] = 0;\n        }\n      }\n    } // check for MIME is true in case of messages GET\n\n\n    if (method === 'GET' && path.indexOf('/messages') >= 0 && params && params.MIME === true) {\n      this.headers.Accept = 'message/rfc2822';\n    }\n\n    debug('%s %s', method, path);\n    const opts = {\n      'hostname': this.host,\n      'port': this.port,\n      'protocol': this.protocol,\n      path,\n      method,\n      'headers': this.headers,\n      'auth': this.auth,\n      'agent': false,\n      'timeout': this.timeout\n    };\n\n    if (this.proxy) {\n      opts.agent = new ProxyAgent(this.proxy);\n    }\n\n    if (this.testMode) {\n      this.testModeLogger(opts, this.payload, this.form);\n      return fn();\n    }\n\n    if (typeof this.retry === 'object' || this.retry > 1) {\n      retry(this.retry, retryCb => {\n        this.callback = retryCb;\n        this.performRequest(opts);\n      }, fn);\n    } else {\n      this.callback = fn;\n      this.performRequest(opts);\n    }\n  }\n\n  request(method, resource, data, fn) {\n    if (typeof data === 'function' && !fn) {\n      fn = data;\n      data = {};\n    }\n\n    if (!data) {\n      data = {};\n    }\n\n    return promisifyCall(this, this._request, method, resource, data, fn);\n  }\n\n  prepareFormData(data) {\n    this.form = new FormData();\n\n    for (const key in data) {\n      if ({}.hasOwnProperty.call(data, key)) {\n        const obj = data[key];\n\n        if (isOk(obj)) {\n          if (key === 'attachment' || key === 'inline') {\n            if (Array.isArray(obj)) {\n              for (let i = 0; i < obj.length; i++) {\n                this.handleAttachmentObject(key, obj[i]);\n              }\n            } else {\n              this.handleAttachmentObject(key, obj);\n            }\n          } else if (key === 'message') {\n            this.handleMimeObject(key, obj);\n          } else if (Array.isArray(obj)) {\n            obj.forEach(element => {\n              if (isOk(element)) {\n                const value = getDataValue(key, element);\n\n                if (isOk(value)) {\n                  this.form.append(key, value);\n                }\n              }\n            });\n          } else {\n            const value = getDataValue(key, obj);\n\n            if (isOk(value)) {\n              this.form.append(key, value);\n            }\n          }\n        }\n      }\n    }\n\n    this.headers = this.form.getHeaders();\n  }\n\n  handleMimeObject(key, obj) {\n    if (typeof obj === 'string') {\n      if (fs.existsSync(obj) && fs.statSync(obj).isFile()) {\n        this.form.append('message', fs.createReadStream(obj));\n      } else {\n        this.form.append('message', Buffer.from(obj), {\n          'filename': 'message.mime',\n          'contentType': 'message/rfc822',\n          'knownLength': obj.length\n        });\n      }\n    } else if (obj instanceof Readable) {\n      this.form.append('message', obj);\n    }\n  }\n\n  handleAttachmentObject(key, obj) {\n    if (!this.form) this.form = new FormData();\n\n    if (Buffer.isBuffer(obj)) {\n      debug('appending buffer to form data. key: %s', key);\n      this.form.append(key, obj, {\n        'filename': 'file'\n      });\n    } else if (typeof obj === 'string') {\n      debug('appending stream to form data. key: %s obj: %s', key, obj);\n      this.form.append(key, fs.createReadStream(obj));\n    } else if (typeof obj === 'object' && obj.readable === true) {\n      debug('appending readable stream to form data. key: %s obj: %s', key, obj);\n      this.form.append(key, obj);\n    } else if (typeof obj === 'object' && obj instanceof Attachment) {\n      const attachmentType = obj.getType();\n\n      if (attachmentType === 'path') {\n        debug('appending attachment stream to form data. key: %s data: %s filename: %s', key, obj.data, obj.filename);\n        this.form.append(key, fs.createReadStream(obj.data), {\n          'filename': obj.filename || 'attached file'\n        });\n      } else if (attachmentType === 'buffer') {\n        debug('appending attachment buffer to form data. key: %s filename: %s', key, obj.filename);\n        const formOpts = {\n          'filename': obj.filename || 'attached file'\n        };\n\n        if (obj.contentType) {\n          formOpts.contentType = obj.contentType;\n        }\n\n        if (obj.knownLength) {\n          formOpts.knownLength = obj.knownLength;\n        }\n\n        this.form.append(key, obj.data, formOpts);\n      } else if (attachmentType === 'stream') {\n        if (obj.knownLength && !obj.contentType || !obj.knownLength && obj.contentType) {\n          debug('missing content type or length for attachment stream. key: %s', key);\n        } else {\n          debug('appending attachment stream to form data. key: %s', key); // add all known options\n\n          let formOpts = {};\n\n          if (obj.filename) {\n            formOpts.filename = obj.filename;\n          }\n\n          if (obj.contentType) {\n            formOpts.contentType = obj.contentType;\n          }\n\n          if (obj.knownLength) {\n            formOpts.knownLength = obj.knownLength;\n          }\n\n          this.form.append(key, obj.data, formOpts);\n        }\n      }\n    } else {\n      debug('unknown attachment type. key: %s', key);\n    }\n  }\n\n  handleResponse(res) {\n    let chunks = '';\n    let error;\n    res.on('data', chunk => {\n      chunks += chunk;\n    });\n    res.on('error', err => {\n      error = err;\n    });\n    res.on('end', () => {\n      let body;\n      debug('response status code: %s content type: %s error: %s', res.statusCode, res.headers['content-type'], error); // FIXME: An ugly hack to overcome invalid response type in mailgun api (see http://bit.ly/1eF30fU).\n      // We skip content-type validation for 'campaings' endpoint assuming it is JSON.\n\n      const skipContentTypeCheck = res.req && res.req.path && res.req.path.match(/\\/campaigns/);\n      const isJSON = res.headers['content-type'] && res.headers['content-type'].indexOf('application/json') >= 0;\n\n      if (chunks && !error && (skipContentTypeCheck || isJSON)) {\n        try {\n          body = JSON.parse(chunks);\n        } catch (e) {\n          error = e;\n        }\n      }\n\n      if (process.env.DEBUG_MAILGUN_FORCE_RETRY) {\n        error = new Error('Force retry error');\n        delete process.env.DEBUG_MAILGUN_FORCE_RETRY;\n      }\n\n      if (!error && res.statusCode !== 200) {\n        let msg = body || chunks || res.statusMessage;\n\n        if (body) {\n          msg = body.message || body.response;\n        }\n\n        error = new Error(msg);\n        error.statusCode = res.statusCode;\n      }\n\n      return this.callback(error, body);\n    });\n  }\n\n  performRequest(options) {\n    const method = options.method;\n\n    if (this.form && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {\n      let alreadyHandled = false;\n      this.form.submit(options, (err, res) => {\n        if (alreadyHandled) {\n          return;\n        }\n\n        alreadyHandled = true;\n\n        if (err) {\n          return this.callback(err);\n        }\n\n        return this.handleResponse(res);\n      });\n    } else {\n      let req;\n\n      if (options.protocol === 'http:') {\n        req = http.request(options, res => {\n          return this.handleResponse(res);\n        });\n      } else {\n        req = https.request(options, res => {\n          return this.handleResponse(res);\n        });\n      }\n\n      if (options.timeout) {\n        req.setTimeout(options.timeout, () => {\n          // timeout occurs\n          req.abort();\n        });\n      }\n\n      req.on('error', e => {\n        return this.callback(e);\n      });\n\n      if (this.payload && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {\n        req.write(this.payload);\n      }\n\n      req.end();\n    }\n  }\n\n  defaultTestModeLogger(httpOptions, payload, formData) {\n    const testlog = debug.enabled ? debug : console.log;\n    testlog('options: %o', httpOptions);\n    testlog('payload: %o', payload);\n    testlog('form: %o', formData);\n  }\n\n}\n\nmodule.exports = Request;","map":{"version":3,"sources":["/Users/owner/Desktop/Naples/ReactJS/Rancell-Portfolio/node_modules/mailgun-js/lib/request.js"],"names":["https","require","http","ProxyAgent","qs","fs","Readable","FormData","Attachment","retry","promisifyCall","debug","isOk","i","getDataValue","key","input","isSpecialParam","JSON","stringify","toString","paramKey","toLowerCase","indexOf","isMultiUnsubsribe","path","data","Array","isArray","prepareData","params","value","Request","constructor","options","host","protocol","port","endpoint","auth","proxy","timeout","testMode","testModeLogger","defaultTestModeLogger","_request","method","resource","fn","concat","payload","isMIME","headers","attachment","inline","message","prepareFormData","Buffer","byteLength","MIME","Accept","opts","agent","form","retryCb","callback","performRequest","request","hasOwnProperty","call","obj","length","handleAttachmentObject","handleMimeObject","forEach","element","append","getHeaders","existsSync","statSync","isFile","createReadStream","from","isBuffer","readable","attachmentType","getType","filename","formOpts","contentType","knownLength","handleResponse","res","chunks","error","on","chunk","err","body","statusCode","skipContentTypeCheck","req","match","isJSON","parse","e","process","env","DEBUG_MAILGUN_FORCE_RETRY","Error","msg","statusMessage","response","alreadyHandled","submit","setTimeout","abort","write","end","httpOptions","formData","testlog","enabled","console","log","module","exports"],"mappings":"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","sourcesContent":["const https = require('https')\nconst http = require('http')\nconst ProxyAgent = require('proxy-agent')\nconst qs = require('querystring')\nconst fs = require('fs')\nconst Readable = require('stream').Readable\nconst FormData = require('form-data')\nconst Attachment = require('./attachment')\nconst retry = require('async').retry\nconst promisifyCall = require('promisify-call')\n\nconst debug = require('debug')('mailgun-js')\n\nfunction isOk (i) {\n  return typeof i !== 'undefined' && i !== null\n}\n\nfunction getDataValue (key, input) {\n  if (isSpecialParam(key) && (typeof input === 'object')) {\n    return JSON.stringify(input)\n  } else if (typeof input === 'number' || typeof input === 'boolean') {\n    return input.toString()\n  }\n\n  return input\n}\n\nfunction isSpecialParam (paramKey) {\n  const key = paramKey.toLowerCase()\n\n  return ((key === 'vars' || key === 'members' || key === 'recipient-variables') || (key.indexOf('v:') === 0))\n}\n\nfunction isMultiUnsubsribe (path, data) {\n  return path.indexOf('/unsubscribes') && data && Array.isArray(data)\n}\n\nfunction prepareData (data) {\n  const params = {}\n\n  for (const key in data) {\n    if (key !== 'attachment' && key !== 'inline' && isOk(data[key])) {\n      const value = getDataValue(key, data[key])\n\n      if (isOk(value)) {\n        params[key] = value\n      }\n    } else {\n      params[key] = data[key]\n    }\n  }\n\n  return params\n}\n\nclass Request {\n  constructor (options) {\n    this.host = options.host\n    this.protocol = options.protocol\n    this.port = options.port\n    this.endpoint = options.endpoint\n    this.auth = options.auth\n    this.proxy = options.proxy\n    this.timeout = options.timeout\n    this.retry = options.retry || 1\n    this.testMode = options.testMode\n    this.testModeLogger = typeof options.testModeLogger === 'function'\n      ? options.testModeLogger : this.defaultTestModeLogger\n  }\n\n  _request (method, resource, data, fn) {\n    let path = ''.concat(this.endpoint, resource)\n\n    const params = prepareData(data)\n\n    this.payload = ''\n\n    const isMIME = path.indexOf('/messages.mime') >= 0\n\n    this.headers = {}\n    if (method === 'GET' || method === 'DELETE') {\n      this.payload = qs.stringify(params)\n      if (this.payload) path = path.concat('?', this.payload)\n    } else {\n      if (isMIME) {\n        this.headers['Content-Type'] = 'multipart/form-data'\n      } else if (method === 'POST' && isMultiUnsubsribe(path, data)) {\n        this.headers['Content-Type'] = 'application/json'\n      } else {\n        this.headers['Content-Type'] = 'application/x-www-form-urlencoded'\n      }\n\n      if (params && (params.attachment || params.inline || (isMIME && params.message))) {\n        this.prepareFormData(params)\n      } else {\n        if (method === 'POST' && isMultiUnsubsribe(path, data)) {\n          this.payload = JSON.stringify(data)\n        } else {\n          this.payload = qs.stringify(params)\n        }\n\n        if (this.payload) {\n          this.headers['Content-Length'] = Buffer.byteLength(this.payload)\n        } else {\n          this.headers['Content-Length'] = 0\n        }\n      }\n    }\n\n    // check for MIME is true in case of messages GET\n    if (method === 'GET' &&\n      path.indexOf('/messages') >= 0 &&\n      params && params.MIME === true) {\n      this.headers.Accept = 'message/rfc2822'\n    }\n\n    debug('%s %s', method, path)\n\n    const opts = {\n      'hostname': this.host,\n      'port': this.port,\n      'protocol': this.protocol,\n      path,\n      method,\n      'headers': this.headers,\n      'auth': this.auth,\n      'agent': false,\n      'timeout': this.timeout\n    }\n\n    if (this.proxy) {\n      opts.agent = new ProxyAgent(this.proxy)\n    }\n\n    if (this.testMode) {\n      this.testModeLogger(opts, this.payload, this.form)\n      return fn()\n    }\n\n    if (typeof this.retry === 'object' || this.retry > 1) {\n      retry(this.retry, (retryCb) => {\n        this.callback = retryCb\n        this.performRequest(opts)\n      }, fn)\n    } else {\n      this.callback = fn\n      this.performRequest(opts)\n    }\n  }\n\n  request (method, resource, data, fn) {\n    if (typeof data === 'function' && !fn) {\n      fn = data\n      data = {}\n    }\n\n    if (!data) {\n      data = {}\n    }\n\n    return promisifyCall(this, this._request, method, resource, data, fn)\n  }\n\n  prepareFormData (data) {\n    this.form = new FormData()\n\n    for (const key in data) {\n      if ({}.hasOwnProperty.call(data, key)) {\n        const obj = data[key]\n\n        if (isOk(obj)) {\n          if (key === 'attachment' || key === 'inline') {\n            if (Array.isArray(obj)) {\n              for (let i = 0; i < obj.length; i++) {\n                this.handleAttachmentObject(key, obj[i])\n              }\n            } else {\n              this.handleAttachmentObject(key, obj)\n            }\n          } else if (key === 'message') {\n            this.handleMimeObject(key, obj)\n          } else if (Array.isArray(obj)) {\n            obj.forEach((element) => {\n              if (isOk(element)) {\n                const value = getDataValue(key, element)\n\n                if (isOk(value)) {\n                  this.form.append(key, value)\n                }\n              }\n            })\n          } else {\n            const value = getDataValue(key, obj)\n\n            if (isOk(value)) {\n              this.form.append(key, value)\n            }\n          }\n        }\n      }\n    }\n\n    this.headers = this.form.getHeaders()\n  }\n\n  handleMimeObject (key, obj) {\n    if (typeof obj === 'string') {\n      if (fs.existsSync(obj) && fs.statSync(obj).isFile()) {\n        this.form.append('message', fs.createReadStream(obj))\n      } else {\n        this.form.append('message', Buffer.from(obj), {\n          'filename': 'message.mime',\n          'contentType': 'message/rfc822',\n          'knownLength': obj.length\n        })\n      }\n    } else if (obj instanceof Readable) {\n      this.form.append('message', obj)\n    }\n  }\n\n  handleAttachmentObject (key, obj) {\n    if (!this.form) this.form = new FormData()\n\n    if (Buffer.isBuffer(obj)) {\n      debug('appending buffer to form data. key: %s', key)\n      this.form.append(key, obj, {\n        'filename': 'file'\n      })\n    } else if (typeof obj === 'string') {\n      debug('appending stream to form data. key: %s obj: %s', key, obj)\n      this.form.append(key, fs.createReadStream(obj))\n    } else if ((typeof obj === 'object') && (obj.readable === true)) {\n      debug('appending readable stream to form data. key: %s obj: %s', key, obj)\n      this.form.append(key, obj)\n    } else if ((typeof obj === 'object') && (obj instanceof Attachment)) {\n      const attachmentType = obj.getType()\n\n      if (attachmentType === 'path') {\n        debug('appending attachment stream to form data. key: %s data: %s filename: %s', key, obj.data, obj.filename)\n        this.form.append(key, fs.createReadStream(obj.data), {\n          'filename': obj.filename || 'attached file'\n        })\n      } else if (attachmentType === 'buffer') {\n        debug('appending attachment buffer to form data. key: %s filename: %s', key, obj.filename)\n        const formOpts = {\n          'filename': obj.filename || 'attached file'\n        }\n\n        if (obj.contentType) {\n          formOpts.contentType = obj.contentType\n        }\n\n        if (obj.knownLength) {\n          formOpts.knownLength = obj.knownLength\n        }\n\n        this.form.append(key, obj.data, formOpts)\n      } else if (attachmentType === 'stream') {\n        if ((obj.knownLength && !obj.contentType) || (!obj.knownLength && obj.contentType)) {\n          debug('missing content type or length for attachment stream. key: %s', key)\n        } else {\n          debug('appending attachment stream to form data. key: %s', key)\n\n          // add all known options\n          let formOpts = {}\n          if (obj.filename) {\n            formOpts.filename = obj.filename\n          }\n          if (obj.contentType) {\n            formOpts.contentType = obj.contentType\n          }\n          if (obj.knownLength) {\n            formOpts.knownLength = obj.knownLength\n          }\n\n          this.form.append(key, obj.data, formOpts)\n        }\n      }\n    } else {\n      debug('unknown attachment type. key: %s', key)\n    }\n  }\n\n  handleResponse (res) {\n    let chunks = ''\n    let error\n\n    res.on('data', (chunk) => {\n      chunks += chunk\n    })\n\n    res.on('error', (err) => {\n      error = err\n    })\n\n    res.on('end', () => {\n      let body\n\n      debug('response status code: %s content type: %s error: %s', res.statusCode, res.headers['content-type'], error)\n\n      // FIXME: An ugly hack to overcome invalid response type in mailgun api (see http://bit.ly/1eF30fU).\n      // We skip content-type validation for 'campaings' endpoint assuming it is JSON.\n      const skipContentTypeCheck = res.req && res.req.path && res.req.path.match(/\\/campaigns/)\n      const isJSON = res.headers['content-type'] && res.headers['content-type'].indexOf('application/json') >= 0\n\n      if (chunks && !error && (skipContentTypeCheck || isJSON)) {\n        try {\n          body = JSON.parse(chunks)\n        } catch (e) {\n          error = e\n        }\n      }\n\n      if (process.env.DEBUG_MAILGUN_FORCE_RETRY) {\n        error = new Error('Force retry error')\n        delete process.env.DEBUG_MAILGUN_FORCE_RETRY\n      }\n\n      if (!error && res.statusCode !== 200) {\n        let msg = body || chunks || res.statusMessage\n\n        if (body) {\n          msg = body.message || body.response\n        }\n\n        error = new Error(msg)\n        error.statusCode = res.statusCode\n      }\n\n      return this.callback(error, body)\n    })\n  }\n\n  performRequest (options) {\n    const method = options.method\n\n    if (this.form && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {\n      let alreadyHandled = false\n      this.form.submit(options, (err, res) => {\n        if (alreadyHandled) {\n          return\n        }\n        alreadyHandled = true\n\n        if (err) {\n          return this.callback(err)\n        }\n\n        return this.handleResponse(res)\n      })\n    } else {\n      let req\n\n      if (options.protocol === 'http:') {\n        req = http.request(options, (res) => {\n          return this.handleResponse(res)\n        })\n      } else {\n        req = https.request(options, (res) => {\n          return this.handleResponse(res)\n        })\n      }\n\n      if (options.timeout) {\n        req.setTimeout(options.timeout, () => {\n          // timeout occurs\n          req.abort()\n        })\n      }\n\n      req.on('error', (e) => {\n        return this.callback(e)\n      })\n\n      if (this.payload && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {\n        req.write(this.payload)\n      }\n\n      req.end()\n    }\n  }\n\n  defaultTestModeLogger (httpOptions, payload, formData) {\n    const testlog = debug.enabled ? debug : console.log\n    testlog('options: %o', httpOptions)\n    testlog('payload: %o', payload)\n    testlog('form: %o', formData)\n  }\n}\n\nmodule.exports = Request\n"]},"metadata":{},"sourceType":"script"}